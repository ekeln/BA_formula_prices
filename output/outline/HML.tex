%
\begin{isabellebody}%
\setisabellecontext{HML}%
%
\isadelimtheory
%
\endisadelimtheory
%
\isatagtheory
%
\endisatagtheory
{\isafoldtheory}%
%
\isadelimtheory
%
\endisadelimtheory
%
\isadelimdocument
%
\endisadelimdocument
%
\isatagdocument
%
\isamarkupsection{Hennessy--Milner logic%
}
\isamarkuptrue%
%
\endisatagdocument
{\isafolddocument}%
%
\isadelimdocument
%
\endisadelimdocument
%
\begin{isamarkuptext}%
For the purpose of this thesis, we focus on the modal-logical characterizations of equivalences, using Hennessy--Milner logic (HML). 
First introduced by Matthew Hennessy and Robin Milner (citation), HML is a modal logic for expressing properties of systems described by LTS.
Intuitively, HML describes observations on an LTS and two processes are considered equivalent under HML if there exists no observation that distinguishes between them.
(citation) defined the modal-logical language as consisting of (finite) conjunctions, negations and a (modal) possibility operator:
$$\varphi ::= t\!t \mid \varphi_1 \;\wedge\; \varphi_2 \mid \neg\varphi \mid \langle\alpha\rangle\varphi$$
(where $\alpha$ ranges over the set of actions.) The paper also proves that this language characterizes a relation that is effectively the same as bisimilarity. 
Thsi theorem is called the Hennessy--Milner Theorem and can be expressed as follows: for image-finite LTSs, two processes are bisimilar iff they satisfy the same set of HML formulas. We call this the modal characterisation of
bisimilarity. (Infinitary) Hennessy--Milner logic extends the original definition by allowing for conjunction of arbitrary width. 
This yields the modal characterization of bisimilarity for arbitrary LTS (cite). In (Section Bisimilarity) provide an intuition of the proof along with the Isabelle proof.
In the following sections we mean the infinitary version when talking about HML.%
\end{isamarkuptext}\isamarkuptrue%
%
\isadelimdocument
%
\endisadelimdocument
%
\isatagdocument
%
\isamarkupsubsubsection{Definition 2.2.1 (Hennessy--Milner logic)%
}
\isamarkuptrue%
%
\endisatagdocument
{\isafolddocument}%
%
\isadelimdocument
%
\endisadelimdocument
%
\begin{isamarkuptext}%
\textbf{Syntax} The syntax of Hennessy--Milner logic over a set $\Sigma$ of actions HML[$\Sigma$] is defined by the grammar:
\begin{align*}
    \varphi &::= \langle a \rangle \varphi && \text{with } a \in \Sigma \\
            &\quad | \, \bigwedge_{i \in I} \psi_i \\
    \psi &::= \neg \varphi \, | \, \varphi.
\end{align*}
Where $I$ denotes an index set.%
\end{isamarkuptext}\isamarkuptrue%
%
\begin{isamarkuptext}%
The data type \isa{{\isacharparenleft}{\kern0pt}{\isacharprime}{\kern0pt}a{\isacharcomma}{\kern0pt}\ {\isacharprime}{\kern0pt}i{\isacharparenright}{\kern0pt}hml} formalizes the definition of HML formulas above. It is parameterized by the type of actions \isa{{\isacharprime}{\kern0pt}a} for $\Sigma$
and an index type \isa{{\isacharprime}{\kern0pt}i}. We use an index sets of arbitrary type \isa{I\ {\isacharcolon}{\kern0pt}{\isacharcolon}{\kern0pt}\ {\isacharprime}{\kern0pt}i\ set} and a mapping \isa{F\ {\isacharcolon}{\kern0pt}{\isacharcolon}{\kern0pt}\ {\isacharprime}{\kern0pt}i\ {\isasymRightarrow}\ {\isacharparenleft}{\kern0pt}{\isacharprime}{\kern0pt}a{\isacharcomma}{\kern0pt}\ {\isacharprime}{\kern0pt}i{\isacharparenright}{\kern0pt}\ hml} to formalize
conjunctions so that each element of \isa{I} is mapped to a formula%
\footnote{Note that the formalization via an arbitrary set, i.e. \isa{hml{\isacharunderscore}{\kern0pt}conj\ {\isasymopen}{\isacharparenleft}{\kern0pt}{\isacharprime}{\kern0pt}a{\isacharparenright}{\kern0pt}hml\ set{\isasymclose}} does not yield a valid type, since \isa{set} is not a bounded natural functor.}%.%
\end{isamarkuptext}\isamarkuptrue%
\isacommand{datatype}\isamarkupfalse%
\ {\isacharparenleft}{\kern0pt}{\isacharprime}{\kern0pt}a{\isacharcomma}{\kern0pt}\ {\isacharprime}{\kern0pt}i{\isacharparenright}{\kern0pt}hml\ {\isacharequal}{\kern0pt}\isanewline
TT\ {\isacharbar}{\kern0pt}\isanewline
hml{\isacharunderscore}{\kern0pt}pos\ {\isacartoucheopen}{\isacharprime}{\kern0pt}a{\isacartoucheclose}\ {\isacartoucheopen}{\isacharparenleft}{\kern0pt}{\isacharprime}{\kern0pt}a{\isacharcomma}{\kern0pt}\ {\isacharprime}{\kern0pt}i{\isacharparenright}{\kern0pt}hml{\isacartoucheclose}\ {\isacharbar}{\kern0pt}\isanewline
hml{\isacharunderscore}{\kern0pt}conj\ {\isacartoucheopen}{\isacharprime}{\kern0pt}i\ set{\isacartoucheclose}\ {\isacartoucheopen}{\isacharprime}{\kern0pt}i\ set{\isacartoucheclose}\ {\isacartoucheopen}{\isacharprime}{\kern0pt}i\ {\isasymRightarrow}\ {\isacharparenleft}{\kern0pt}{\isacharprime}{\kern0pt}a{\isacharcomma}{\kern0pt}\ {\isacharprime}{\kern0pt}i{\isacharparenright}{\kern0pt}\ hml{\isacartoucheclose}%
\begin{isamarkuptext}%
Note that in canonical definitions of HML \isa{TT} is not usually part of the syntax,
but is instead synonymous to \isa{{\isasymAnd}{\isacharbraceleft}{\kern0pt}{\isacharbraceright}{\kern0pt}}.
We include \isa{TT} in the definition to enable Isabelle to infer that the type \isa{hml} is not empty..
Corresponding to the mathematical definition, this formalization allows for conjunctions of arbitrary - even of infinite - width.%
\end{isamarkuptext}\isamarkuptrue%
%
\begin{isamarkuptext}%
\textbf{Semantics} The semantics of HML parametrized by $\Sigma$ (on LTS processes) are given by the relation $\models$ : $(\Proc, \text{HML}[\Sigma])$:
\begin{align*}
  p &\models \langle \alpha \rangle\varphi && \text{if there exists } q \text{ such that } q\in\mathit{Der}(p, \alpha) \text{ and } q \models\varphi \\
  p &\models \bigwedge_{i \in I} \psi_i && \text{if } p\models\psi_i \text{ for all } i\in I \\
  p &\models \lnot\varphi && \text{if } p\not\models\varphi
\end{align*}%
\end{isamarkuptext}\isamarkuptrue%
\isacommand{context}\isamarkupfalse%
\ lts\ \isakeyword{begin}\isanewline
\isanewline
\isacommand{primrec}\isamarkupfalse%
\ hml{\isacharunderscore}{\kern0pt}semantics\ {\isacharcolon}{\kern0pt}{\isacharcolon}{\kern0pt}\ {\isacartoucheopen}{\isacharprime}{\kern0pt}s\ {\isasymRightarrow}\ {\isacharparenleft}{\kern0pt}{\isacharprime}{\kern0pt}a{\isacharcomma}{\kern0pt}\ {\isacharprime}{\kern0pt}s{\isacharparenright}{\kern0pt}hml\ {\isasymRightarrow}\ bool{\isacartoucheclose}\isanewline
{\isacharparenleft}{\kern0pt}{\isacartoucheopen}{\isacharunderscore}{\kern0pt}\ {\isasymTurnstile}\ {\isacharunderscore}{\kern0pt}{\isacartoucheclose}\ {\isacharbrackleft}{\kern0pt}{\isadigit{5}}{\isadigit{0}}{\isacharcomma}{\kern0pt}\ {\isadigit{5}}{\isadigit{0}}{\isacharbrackright}{\kern0pt}\ {\isadigit{5}}{\isadigit{0}}{\isacharparenright}{\kern0pt}\isanewline
\isakeyword{where}\isanewline
hml{\isacharunderscore}{\kern0pt}sem{\isacharunderscore}{\kern0pt}tt{\isacharcolon}{\kern0pt}\ {\isacartoucheopen}{\isacharparenleft}{\kern0pt}{\isacharunderscore}{\kern0pt}\ {\isasymTurnstile}\ TT{\isacharparenright}{\kern0pt}\ {\isacharequal}{\kern0pt}\ True{\isacartoucheclose}\ {\isacharbar}{\kern0pt}\isanewline
hml{\isacharunderscore}{\kern0pt}sem{\isacharunderscore}{\kern0pt}pos{\isacharcolon}{\kern0pt}\ {\isacartoucheopen}{\isacharparenleft}{\kern0pt}p\ {\isasymTurnstile}\ {\isacharparenleft}{\kern0pt}hml{\isacharunderscore}{\kern0pt}pos\ {\isasymalpha}\ {\isasymphi}{\isacharparenright}{\kern0pt}{\isacharparenright}{\kern0pt}\ {\isacharequal}{\kern0pt}\ {\isacharparenleft}{\kern0pt}{\isasymexists}\ q{\isachardot}{\kern0pt}\ {\isacharparenleft}{\kern0pt}p\ {\isasymmapsto}{\isasymalpha}\ q{\isacharparenright}{\kern0pt}\ {\isasymand}\ q\ {\isasymTurnstile}\ {\isasymphi}{\isacharparenright}{\kern0pt}{\isacartoucheclose}\ {\isacharbar}{\kern0pt}\isanewline
hml{\isacharunderscore}{\kern0pt}sem{\isacharunderscore}{\kern0pt}conj{\isacharcolon}{\kern0pt}\ {\isacartoucheopen}{\isacharparenleft}{\kern0pt}p\ {\isasymTurnstile}\ {\isacharparenleft}{\kern0pt}hml{\isacharunderscore}{\kern0pt}conj\ I\ J\ {\isasympsi}s{\isacharparenright}{\kern0pt}{\isacharparenright}{\kern0pt}\ {\isacharequal}{\kern0pt}\ {\isacharparenleft}{\kern0pt}{\isacharparenleft}{\kern0pt}{\isasymforall}i\ {\isasymin}\ I{\isachardot}{\kern0pt}\ p\ {\isasymTurnstile}\ {\isacharparenleft}{\kern0pt}{\isasympsi}s\ i{\isacharparenright}{\kern0pt}{\isacharparenright}{\kern0pt}\ {\isasymand}\ {\isacharparenleft}{\kern0pt}{\isasymforall}j\ {\isasymin}\ J{\isachardot}{\kern0pt}\ {\isasymnot}{\isacharparenleft}{\kern0pt}p\ {\isasymTurnstile}\ {\isacharparenleft}{\kern0pt}{\isasympsi}s\ j{\isacharparenright}{\kern0pt}{\isacharparenright}{\kern0pt}{\isacharparenright}{\kern0pt}{\isacharparenright}{\kern0pt}{\isacartoucheclose}%
\begin{isamarkuptext}%
A formula that is true for all processes in a LTS can be considered a property that holds universally for the system, akin to a tautology in classical logic.%
\end{isamarkuptext}\isamarkuptrue%
\isacommand{definition}\isamarkupfalse%
\ HML{\isacharunderscore}{\kern0pt}true\ \isakeyword{where}\isanewline
{\isachardoublequoteopen}HML{\isacharunderscore}{\kern0pt}true\ {\isasymphi}\ {\isasymequiv}\ {\isasymforall}s{\isachardot}{\kern0pt}\ s\ {\isasymTurnstile}\ {\isasymphi}{\isachardoublequoteclose}\isanewline
%
\isadelimproof
%
\endisadelimproof
%
\isatagproof
%
\endisatagproof
{\isafoldproof}%
%
\isadelimproof
%
\endisadelimproof
%
\begin{isamarkuptext}%
Two states are HML-equivalent if they satisfy the same formula.%
\end{isamarkuptext}\isamarkuptrue%
\isacommand{definition}\isamarkupfalse%
\ HML{\isacharunderscore}{\kern0pt}equivalent\ {\isacharcolon}{\kern0pt}{\isacharcolon}{\kern0pt}\ {\isacartoucheopen}{\isacharprime}{\kern0pt}s\ {\isasymRightarrow}\ {\isacharprime}{\kern0pt}s\ {\isasymRightarrow}\ bool{\isacartoucheclose}\ \isakeyword{where}\isanewline
\ \ {\isacartoucheopen}HML{\isacharunderscore}{\kern0pt}equivalent\ p\ q\ {\isasymequiv}\ {\isacharparenleft}{\kern0pt}{\isasymforall}\ {\isasymphi}{\isacharcolon}{\kern0pt}{\isacharcolon}{\kern0pt}{\isacharparenleft}{\kern0pt}{\isacharprime}{\kern0pt}a{\isacharcomma}{\kern0pt}\ {\isacharprime}{\kern0pt}s{\isacharparenright}{\kern0pt}\ hml{\isachardot}{\kern0pt}\ {\isacharparenleft}{\kern0pt}p\ {\isasymTurnstile}\ {\isasymphi}{\isacharparenright}{\kern0pt}\ {\isasymlongleftrightarrow}\ {\isacharparenleft}{\kern0pt}q\ {\isasymTurnstile}\ {\isasymphi}{\isacharparenright}{\kern0pt}{\isacharparenright}{\kern0pt}{\isacartoucheclose}\isanewline
%
\isadelimproof
%
\endisadelimproof
%
\isatagproof
%
\endisatagproof
{\isafoldproof}%
%
\isadelimproof
%
\endisadelimproof
%
\begin{isamarkuptext}%
HML-equivalence is reflexive, symmetrical and transitive and therefore a valid equivalence.%
\end{isamarkuptext}\isamarkuptrue%
\isacommand{lemma}\isamarkupfalse%
\ equiv{\isacharunderscore}{\kern0pt}refl{\isacharcolon}{\kern0pt}\ {\isachardoublequoteopen}reflp\ HML{\isacharunderscore}{\kern0pt}equivalent{\isachardoublequoteclose}\isanewline
%
\isadelimproof
\ \ %
\endisadelimproof
%
\isatagproof
\isacommand{by}\isamarkupfalse%
\ {\isacharparenleft}{\kern0pt}simp\ add{\isacharcolon}{\kern0pt}\ HML{\isacharunderscore}{\kern0pt}equivalent{\isacharunderscore}{\kern0pt}def\ reflpI{\isacharparenright}{\kern0pt}%
\endisatagproof
{\isafoldproof}%
%
\isadelimproof
\isanewline
%
\endisadelimproof
\isanewline
\isacommand{lemma}\isamarkupfalse%
\ equiv{\isacharunderscore}{\kern0pt}trans{\isacharcolon}{\kern0pt}\ {\isachardoublequoteopen}transp\ HML{\isacharunderscore}{\kern0pt}equivalent{\isachardoublequoteclose}\isanewline
%
\isadelimproof
\ \ %
\endisadelimproof
%
\isatagproof
\isacommand{by}\isamarkupfalse%
\ {\isacharparenleft}{\kern0pt}simp\ add{\isacharcolon}{\kern0pt}\ HML{\isacharunderscore}{\kern0pt}equivalent{\isacharunderscore}{\kern0pt}def\ transp{\isacharunderscore}{\kern0pt}def{\isacharparenright}{\kern0pt}%
\endisatagproof
{\isafoldproof}%
%
\isadelimproof
\isanewline
%
\endisadelimproof
\isanewline
\isacommand{lemma}\isamarkupfalse%
\ hml{\isacharunderscore}{\kern0pt}equiv{\isacharunderscore}{\kern0pt}sym{\isacharcolon}{\kern0pt}\isanewline
\ \ \isakeyword{shows}\ {\isacartoucheopen}symp\ HML{\isacharunderscore}{\kern0pt}equivalent{\isacartoucheclose}\isanewline
%
\isadelimproof
\ \ %
\endisadelimproof
%
\isatagproof
\isacommand{unfolding}\isamarkupfalse%
\ HML{\isacharunderscore}{\kern0pt}equivalent{\isacharunderscore}{\kern0pt}def\ symp{\isacharunderscore}{\kern0pt}def\ \isacommand{by}\isamarkupfalse%
\ simp%
\endisatagproof
{\isafoldproof}%
%
\isadelimproof
%
\endisadelimproof
%
\begin{isamarkuptext}%
A formula distinguishes one state from another if its true for the first and false for the second.%
\end{isamarkuptext}\isamarkuptrue%
\isacommand{abbreviation}\isamarkupfalse%
\ distinguishes\ {\isacharcolon}{\kern0pt}{\isacharcolon}{\kern0pt}\ \ {\isacartoucheopen}{\isacharparenleft}{\kern0pt}{\isacharprime}{\kern0pt}a{\isacharcomma}{\kern0pt}\ {\isacharprime}{\kern0pt}s{\isacharparenright}{\kern0pt}\ hml\ {\isasymRightarrow}\ {\isacharprime}{\kern0pt}s\ {\isasymRightarrow}\ {\isacharprime}{\kern0pt}s\ {\isasymRightarrow}\ bool{\isacartoucheclose}\ \isakeyword{where}\isanewline
\ \ \ {\isacartoucheopen}distinguishes\ {\isasymphi}\ p\ q\ {\isasymequiv}\ p\ {\isasymTurnstile}\ {\isasymphi}\ {\isasymand}\ {\isasymnot}\ q\ {\isasymTurnstile}\ {\isasymphi}{\isacartoucheclose}%
\begin{isamarkuptext}%
If two states are not HML equivalent then there must be a
  distinguishing formula.%
\end{isamarkuptext}\isamarkuptrue%
\isacommand{lemma}\isamarkupfalse%
\ hml{\isacharunderscore}{\kern0pt}distinctions{\isacharcolon}{\kern0pt}\isanewline
\ \ \isakeyword{fixes}\ state{\isacharcolon}{\kern0pt}{\isacharcolon}{\kern0pt}\ {\isacharprime}{\kern0pt}s\isanewline
\ \ \isakeyword{assumes}\ {\isacartoucheopen}{\isasymnot}\ HML{\isacharunderscore}{\kern0pt}equivalent\ p\ q{\isacartoucheclose}\isanewline
\ \ \isakeyword{shows}\ {\isacartoucheopen}{\isasymexists}{\isasymphi}{\isachardot}{\kern0pt}\ distinguishes\ {\isasymphi}\ p\ q{\isacartoucheclose}\isanewline
%
\isadelimproof
%
\endisadelimproof
%
\isatagproof
\isacommand{proof}\isamarkupfalse%
{\isacharminus}{\kern0pt}\isanewline
\ \ \isacommand{from}\isamarkupfalse%
\ assms\ \isacommand{have}\isamarkupfalse%
\ {\isachardoublequoteopen}{\isasymnot}\ {\isacharparenleft}{\kern0pt}{\isasymforall}\ {\isasymphi}{\isacharcolon}{\kern0pt}{\isacharcolon}{\kern0pt}{\isacharparenleft}{\kern0pt}{\isacharprime}{\kern0pt}a{\isacharcomma}{\kern0pt}\ {\isacharprime}{\kern0pt}s{\isacharparenright}{\kern0pt}\ hml{\isachardot}{\kern0pt}\ {\isacharparenleft}{\kern0pt}p\ {\isasymTurnstile}\ {\isasymphi}{\isacharparenright}{\kern0pt}\ {\isasymlongleftrightarrow}\ {\isacharparenleft}{\kern0pt}q\ {\isasymTurnstile}\ {\isasymphi}{\isacharparenright}{\kern0pt}{\isacharparenright}{\kern0pt}{\isachardoublequoteclose}\ \isanewline
\ \ \ \ \isacommand{unfolding}\isamarkupfalse%
\ HML{\isacharunderscore}{\kern0pt}equivalent{\isacharunderscore}{\kern0pt}def\ \isacommand{by}\isamarkupfalse%
\ blast\isanewline
\ \ \isacommand{then}\isamarkupfalse%
\ \isacommand{obtain}\isamarkupfalse%
\ {\isasymphi}{\isacharcolon}{\kern0pt}{\isacharcolon}{\kern0pt}{\isachardoublequoteopen}{\isacharparenleft}{\kern0pt}{\isacharprime}{\kern0pt}a{\isacharcomma}{\kern0pt}\ {\isacharprime}{\kern0pt}s{\isacharparenright}{\kern0pt}\ hml{\isachardoublequoteclose}\ \isakeyword{where}\ {\isachardoublequoteopen}{\isacharparenleft}{\kern0pt}p\ {\isasymTurnstile}\ {\isasymphi}{\isacharparenright}{\kern0pt}\ {\isasymnoteq}\ {\isacharparenleft}{\kern0pt}q\ {\isasymTurnstile}\ {\isasymphi}{\isacharparenright}{\kern0pt}{\isachardoublequoteclose}\ \isacommand{by}\isamarkupfalse%
\ blast\isanewline
\ \ \isacommand{then}\isamarkupfalse%
\ \isacommand{have}\isamarkupfalse%
\ {\isachardoublequoteopen}{\isacharparenleft}{\kern0pt}{\isacharparenleft}{\kern0pt}p\ {\isasymTurnstile}\ {\isasymphi}{\isacharparenright}{\kern0pt}\ {\isasymand}\ {\isasymnot}{\isacharparenleft}{\kern0pt}q\ {\isasymTurnstile}\ {\isasymphi}{\isacharparenright}{\kern0pt}{\isacharparenright}{\kern0pt}\ {\isasymor}\ {\isacharparenleft}{\kern0pt}{\isasymnot}{\isacharparenleft}{\kern0pt}p\ {\isasymTurnstile}\ {\isasymphi}{\isacharparenright}{\kern0pt}\ {\isasymand}\ {\isacharparenleft}{\kern0pt}q\ {\isasymTurnstile}\ {\isasymphi}{\isacharparenright}{\kern0pt}{\isacharparenright}{\kern0pt}{\isachardoublequoteclose}\isanewline
\ \ \ \ \isacommand{by}\isamarkupfalse%
\ blast\isanewline
\ \ \isacommand{then}\isamarkupfalse%
\ \isacommand{show}\isamarkupfalse%
\ {\isacharquery}{\kern0pt}thesis\isanewline
\ \ \isacommand{proof}\isamarkupfalse%
\isanewline
\ \ \ \ \isacommand{show}\isamarkupfalse%
\ {\isachardoublequoteopen}distinguishes\ {\isasymphi}\ p\ q\ {\isasymLongrightarrow}\ {\isasymexists}{\isasymphi}{\isachardot}{\kern0pt}\ distinguishes\ {\isasymphi}\ p\ q{\isachardoublequoteclose}\ \isacommand{by}\isamarkupfalse%
\ blast\isanewline
\ \ \isacommand{next}\isamarkupfalse%
\isanewline
\ \ \ \ \isacommand{assume}\isamarkupfalse%
\ assm{\isacharcolon}{\kern0pt}\ {\isachardoublequoteopen}{\isasymnot}\ p\ {\isasymTurnstile}\ {\isasymphi}\ {\isasymand}\ q\ {\isasymTurnstile}\ {\isasymphi}{\isachardoublequoteclose}\isanewline
\ \ \ \ \isacommand{define}\isamarkupfalse%
\ n{\isasymphi}\ \isakeyword{where}\ {\isachardoublequoteopen}n{\isasymphi}\ {\isasymequiv}{\isacharparenleft}{\kern0pt}hml{\isacharunderscore}{\kern0pt}conj\ {\isacharparenleft}{\kern0pt}{\isacharbraceleft}{\kern0pt}{\isacharbraceright}{\kern0pt}{\isacharcolon}{\kern0pt}{\isacharcolon}{\kern0pt}{\isacharprime}{\kern0pt}s\ set{\isacharparenright}{\kern0pt}\ \isanewline
\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ {\isacharbraceleft}{\kern0pt}state{\isacharbraceright}{\kern0pt}\ \isanewline
\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ {\isacharparenleft}{\kern0pt}{\isasymlambda}j{\isachardot}{\kern0pt}\ if\ j\ {\isacharequal}{\kern0pt}\ state\ then\ {\isasymphi}\ else\ undefined{\isacharparenright}{\kern0pt}{\isacharparenright}{\kern0pt}{\isachardoublequoteclose}\isanewline
\ \ \ \ \isacommand{have}\isamarkupfalse%
\ {\isachardoublequoteopen}p\ {\isasymTurnstile}\ n{\isasymphi}\ {\isasymand}\ {\isasymnot}\ q\ {\isasymTurnstile}\ n{\isasymphi}{\isachardoublequoteclose}\ \isanewline
\ \ \ \ \ \ \isacommand{unfolding}\isamarkupfalse%
\ n{\isasymphi}{\isacharunderscore}{\kern0pt}def\isanewline
\ \ \ \ \ \ \isacommand{using}\isamarkupfalse%
\ hml{\isacharunderscore}{\kern0pt}semantics{\isachardot}{\kern0pt}simps\ assm\isanewline
\ \ \ \ \ \ \isacommand{by}\isamarkupfalse%
\ force\isanewline
\ \ \ \ \isacommand{then}\isamarkupfalse%
\ \isacommand{show}\isamarkupfalse%
\ {\isacharquery}{\kern0pt}thesis\isanewline
\ \ \ \ \ \ \isacommand{by}\isamarkupfalse%
\ blast\isanewline
\ \ \isacommand{qed}\isamarkupfalse%
\isanewline
\isacommand{qed}\isamarkupfalse%
%
\endisatagproof
{\isafoldproof}%
%
\isadelimproof
%
\endisadelimproof
%
\begin{isamarkuptext}%
We can now use HML to capture differences between $p_1$ and $q_1$ of (ref Example 1). The formula
$\langle a \rangle\bigwedge\{\lnot\langle c \rangle\}$ distinguishes $p_1$ from $q_1$ and $\langle a \rangle\bigwedge\{\langle c \rangle\}$ distinguishes
$q_1$ from $p_1$. From the Hennessy--Milner Theorem follows that knowing a distinguishing formula means that $p_1$ and $q_1$ are not bisimilar.%
\end{isamarkuptext}\isamarkuptrue%
%
\isadelimproof
%
\endisadelimproof
%
\isatagproof
%
\endisatagproof
{\isafoldproof}%
%
\isadelimproof
%
\endisadelimproof
%
\isadelimdocument
%
\endisadelimdocument
%
\isatagdocument
%
\endisatagdocument
{\isafolddocument}%
%
\isadelimdocument
%
\endisadelimdocument
%
\isadelimproof
%
\endisadelimproof
%
\isatagproof
%
\endisatagproof
{\isafoldproof}%
%
\isadelimproof
\isanewline
%
\endisadelimproof
\isacommand{end}\isamarkupfalse%
\ \isanewline
%
\isadelimtheory
%
\endisadelimtheory
%
\isatagtheory
%
\endisatagtheory
{\isafoldtheory}%
%
\isadelimtheory
%
\endisadelimtheory
%
\end{isabellebody}%
\endinput
%:%file=~/Documents/Isabelle_HOL/HML.thy%:%
%:%24=7%:%
%:%36=9%:%
%:%37=10%:%
%:%38=11%:%
%:%39=12%:%
%:%40=13%:%
%:%41=14%:%
%:%42=15%:%
%:%43=16%:%
%:%44=17%:%
%:%45=18%:%
%:%54=20%:%
%:%66=21%:%
%:%67=22%:%
%:%68=23%:%
%:%69=24%:%
%:%70=25%:%
%:%71=26%:%
%:%72=27%:%
%:%76=29%:%
%:%77=30%:%
%:%78=31%:%
%:%79=32%:%
%:%81=34%:%
%:%82=34%:%
%:%83=35%:%
%:%84=36%:%
%:%85=37%:%
%:%87=39%:%
%:%88=40%:%
%:%89=41%:%
%:%90=42%:%
%:%94=44%:%
%:%95=45%:%
%:%96=46%:%
%:%97=47%:%
%:%98=48%:%
%:%99=49%:%
%:%101=51%:%
%:%102=51%:%
%:%103=52%:%
%:%104=53%:%
%:%105=53%:%
%:%106=54%:%
%:%107=55%:%
%:%108=56%:%
%:%109=57%:%
%:%110=58%:%
%:%112=60%:%
%:%114=61%:%
%:%115=61%:%
%:%116=62%:%
%:%132=72%:%
%:%134=73%:%
%:%135=73%:%
%:%136=74%:%
%:%152=85%:%
%:%154=87%:%
%:%155=87%:%
%:%158=88%:%
%:%162=88%:%
%:%163=88%:%
%:%168=88%:%
%:%171=89%:%
%:%172=90%:%
%:%173=90%:%
%:%176=91%:%
%:%180=91%:%
%:%181=91%:%
%:%186=91%:%
%:%189=92%:%
%:%190=93%:%
%:%191=93%:%
%:%192=94%:%
%:%195=95%:%
%:%199=95%:%
%:%200=95%:%
%:%201=95%:%
%:%210=97%:%
%:%212=99%:%
%:%213=99%:%
%:%214=100%:%
%:%216=103%:%
%:%217=104%:%
%:%219=106%:%
%:%220=106%:%
%:%221=107%:%
%:%222=108%:%
%:%223=109%:%
%:%230=110%:%
%:%231=110%:%
%:%232=111%:%
%:%233=111%:%
%:%234=111%:%
%:%235=112%:%
%:%236=112%:%
%:%237=112%:%
%:%238=113%:%
%:%239=113%:%
%:%240=113%:%
%:%241=113%:%
%:%242=114%:%
%:%243=114%:%
%:%244=114%:%
%:%245=115%:%
%:%246=115%:%
%:%247=116%:%
%:%248=116%:%
%:%249=116%:%
%:%250=117%:%
%:%251=117%:%
%:%252=118%:%
%:%253=118%:%
%:%254=118%:%
%:%255=119%:%
%:%256=119%:%
%:%257=120%:%
%:%258=120%:%
%:%259=121%:%
%:%260=121%:%
%:%262=123%:%
%:%263=124%:%
%:%264=124%:%
%:%265=125%:%
%:%266=125%:%
%:%267=126%:%
%:%268=126%:%
%:%269=127%:%
%:%270=127%:%
%:%271=128%:%
%:%272=128%:%
%:%273=128%:%
%:%274=129%:%
%:%275=129%:%
%:%276=130%:%
%:%277=130%:%
%:%278=131%:%
%:%288=133%:%
%:%289=134%:%
%:%290=135%:%
%:%329=166%:%
%:%332=167%:%
%:%333=167%:%
